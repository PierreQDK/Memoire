---
title: "prpre"
format: html
editor: visual
---

# CHARGEMENT DES LIBRAIRIES

```{r setup, include=FALSE}
# Chargement des librairies (comme dans ton script)
# Chargement des librairies n√©cessaires
library(tibble)
library(readxl)
library(dplyr)
library(ggplot2)
library(broom)
library(outliers)
library(DescTools)
library(EnvStats)
library(fBasics)
library(plm)
library(lmtest)
library(haven)
library(writexl)
library(zoo)
library(lubridate)
library(clubSandwich)
library(DIDmultiplegt)
library(synthdid)
library(ggallin)
library(ggthemes)
library(ggridges)
library(GGally)
library(ggeffects)
library(effects)
library(gtsummary)
library(stats)
library(ggcorrplot)
library(ggTimeSeries)
library(car)
library(plotly)
library(tidyr)
library(tidyverse)
library(conflicted)
library(elo)
library(forecast)
library(nortsTest)
library(strucchange)
library(bsts)
library(Hmisc)
library(stargazer)
library(performance)
library(Kendall)
library(naniar)
library(scales)
library(mgcv)
library(e1071)
library(roll)
library(EnvCpt)
library(viridis)
library(ineq)
library(gglorenz)
library(gridExtra)
library(changepoint)
library(openxlsx)
library(corrplot)
library(PerformanceAnalytics)
library(sjPlot)
library(FactoMineR)
library(factoextra)
library(reshape2)
library(MASS)
library(AER)
```

# TRANSFORMATION DE DATE

```{r date-fn}
toDate <- function(year, month, day) {
  ISOdate(year, month, day)
}
```

# IMPORT ET NETTOYAGE DES DONN√âES 

```{r import-clean}
a1 <- read_excel("daily_futures_prices_1920s.xlsx", sheet = "panel7")
a1$Date <- as.Date(toDate(a1$Year, a1$Month, a1$Day))
a1$Treatment <- ifelse(grepl("CHI", a1$Indiv), 1, 0)
a1$Post <- ifelse(a1$Date >= as.Date("1926-02-01"), 1, 0)
a1$Treat_Post <- a1$Treatment * a1$Post
a1 <- pdata.frame(a1, index = c("Indiv", "Date"))
a1$Date <- as.Date(as.character(a1$Date))  # Correction type date
pdim(a1)
```


# STATISTIQUES DESCRIPTIVES
## WHEAT - Chicago
```{r}
wheat_chicago <- a1 %>%
  filter(grepl("WHEAT", Indiv), grepl("CHI", Indiv), !is.na(Close))

basicStats(as.numeric(wheat_chicago$Close))
range(wheat_chicago$Date)

```
## WHEAT - Autres villes
```{r}
library(dplyr)
library(fBasics)

# Filtrer les contrats WHEAT hors Chicago
wheat_autres <- a1 %>%
  filter(grepl("WHEAT", Indiv), !grepl("CHI", Indiv), !is.na(Close))

# Calcul des statistiques
basicStats(as.numeric(wheat_autres$Close))

```



```{r}
# Extraire les identifiants "autres" pour WHEAT et CORN
autres_villes <- a1 %>%
  filter(grepl("WHEAT|CORN", Indiv), !grepl("CHI", Indiv)) %>%
  distinct(Indiv) %>%
  arrange(Indiv)

print(autres_villes)

```

## CORN - Chicago

```{r}
library(dplyr)
library(fBasics)

# Filtrer les contrats CORN √† Chicago
corn_chicago <- a1 %>%
  filter(grepl("CORN", Indiv), grepl("CHI", Indiv), !is.na(Close))

# Statistiques descriptives
basicStats(as.numeric(corn_chicago$Close))

```


## CORN - Autres villes

```{r}
# Filtrer les contrats CORN hors Chicago
corn_autres <- a1 %>%
  filter(grepl("CORN", Indiv), !grepl("CHI", Indiv), !is.na(Close))

# Statistiques descriptives
basicStats(as.numeric(corn_autres$Close))

```



# TEST DES VALEURS ATYPIQUES

## Graphiques CORN

```{r}
# Extraction du data.frame simple
a1_df <- as.data.frame(a1)

# Filtrage des donn√©es CORN
corn_filtered <- a1_df %>%
  filter(!is.na(Close),
         grepl("CORN", Indiv),
         grepl("MAY|JULY", Indiv),
         grepl("CHI|KC|STL", Indiv)) %>%
  mutate(Ville = case_when(
    grepl("CHI", Indiv) ~ "Chicago",
    grepl("KC", Indiv) ~ "Kansas City",
    grepl("STL", Indiv) ~ "Saint Louis"
  ))

# Boxplot pour CORN
ggplot(corn_filtered, aes(x = reorder(Indiv, Close, FUN = median), y = Close, fill = Ville)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 8) +
  labs(
    x = "Contrat √† terme",
    y = "Prix de cl√¥ture"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

```

### Graphique CORN MAY

```{r}
# Boxplot pour CORN MAY
corn_may <- corn_filtered %>%
  filter(grepl("MAY", Indiv))

ggplot(corn_may, aes(x = reorder(Indiv, Close, FUN = median), y = Close, fill = Ville)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 8) +
  labs(
    x = "Contrat √† terme",
    y = "Prix de cl√¥ture"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
```

### Graphique CORN JULY

```{r}
# Boxplot pour CORN JULY
corn_july <- corn_filtered %>%
  filter(grepl("JULY", Indiv))

ggplot(corn_july, aes(x = reorder(Indiv, Close, FUN = median), y = Close, fill = Ville)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 8) +
  labs(
    x = "Contrat √† terme",
    y = "Prix de cl√¥ture"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

```

## Graphiques WHEAT 

```{r}
# Filtrage des donn√©es WHEAT
wheat_filtered <- a1_df %>%
  filter(!is.na(Close),
         grepl("WHEAT", Indiv),
         grepl("MAY|JULY", Indiv),
         grepl("CHI|KC|STL", Indiv)) %>%
  mutate(Ville = case_when(
    grepl("CHI", Indiv) ~ "Chicago",
    grepl("KC", Indiv) ~ "Kansas City",
    grepl("STL", Indiv) ~ "Saint Louis"
  ))

# Boxplot global pour WHEAT MAY & JULY
ggplot(wheat_filtered, aes(x = reorder(Indiv, Close, FUN = median), y = Close, fill = Ville)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 8) +
  labs(
    x = "Contrat √† terme",
    y = "Prix de cl√¥ture"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

```


## Graphique WHEAT May
```{r}
# Filtrage des donn√©es WHEAT
wheat_filtered <- a1_df %>%
  filter(!is.na(Close),
         grepl("WHEAT", Indiv),
         grepl("MAY|JULY", Indiv),
         grepl("CHI|KC|STL", Indiv)) %>%
  mutate(Ville = case_when(
    grepl("CHI", Indiv) ~ "Chicago",
    grepl("KC", Indiv) ~ "Kansas City",
    grepl("STL", Indiv) ~ "Saint Louis"
  ))

# Boxplot pour WHEAT MAY
wheat_may <- wheat_filtered %>%
  filter(grepl("MAY", Indiv))

ggplot(wheat_may, aes(x = reorder(Indiv, Close, FUN = median), y = Close, fill = Ville)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 8) +
  labs(
    x = "Contrat √† terme",
    y = "Prix de cl√¥ture"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
```

## Graphique WHEAT JULY

```{r}
# Boxplot pour WHEAT JULY
wheat_july <- wheat_filtered %>%
  filter(grepl("JULY", Indiv))

ggplot(wheat_july, aes(x = reorder(Indiv, Close, FUN = median), y = Close, fill = Ville)) +
  geom_boxplot(outlier.color = "red", outlier.shape = 8) +
  labs(
    x = "Contrat √† terme",
    y = "Prix de cl√¥ture"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

```

## Tests statistiques des valeurs atypiques avec Rosner Test


```{r}

# Appliquer le test de Rosner sur le prix de cl√¥ture (Close)
res_close <- rosnerTest(a1$Close, k = 10, alpha = 0.05)  # k = 10 permet de tester jusqu'√† 10 points atypiques

# Affichage des r√©sultats du test de Rosner pour "Close"
cat("R√©sultats du test de Rosner pour le prix de cl√¥ture (Close): \n")
print(res_close)

```






# ESTIMATION DES TENDANCES PARALL√àLES


## Test statistique des tendances parall√®les
```{r}


# ‚öôÔ∏è Pr√©traitement des donn√©es
a1_pre <- a1 %>%
  filter(Date < as.Date("1926-02-01")) %>%
  mutate(
    time_to_treat = as.numeric(Date - as.Date("1925-01-01")),
    Treatment = ifelse(grepl("CHI", Indiv), 1, 0)
  )

# üüß FONCTION de test des tendances parall√®les
test_parallel <- function(data, label) {
  data <- data %>%
    mutate(Interaction = Treatment * time_to_treat)

  model <- lm(Close ~ time_to_treat + Treatment + Interaction, data = data)
  result <- tidy(model) %>% filter(term == "Interaction")

  if (nrow(result) == 0) return(NULL)

  pval <- result$p.value
  sig <- ifelse(pval < 0.01, "***", ifelse(pval < 0.05, "**", ifelse(pval < 0.1, "*", "")))

  tibble(
    Commodity = label,
    coef = round(result$estimate, 3),
    p_value = round(pval, 3),
    stars = sig
  )
}

# üîπ Test pour le CORN
corn_data <- a1_pre %>% filter(grepl("CORN", Indiv, ignore.case = TRUE))
res_corn <- test_parallel(corn_data, "CORN")

# üîπ Test pour le WHEAT
wheat_data <- a1_pre %>% filter(grepl("WHEAT", Indiv, ignore.case = TRUE))
res_wheat <- test_parallel(wheat_data, "WHEAT")

# üìä R√©sultat global
test_parallel_results <- bind_rows(res_corn, res_wheat)
print(test_parallel_results)

```

il n‚Äôy a pas de diff√©rence significative dans les tendances pr√©-traitement entre le groupe trait√© et les autres.

## Repr√©sentation graphique des tendances pr√©-traitement
```{r}


# üîπ √âtape 1 : filtrer p√©riode pr√©-traitement
a1_pre <- a1 %>%
  filter(Date < as.Date("1926-02-01")) %>%
  mutate(
    Treatment = ifelse(grepl("CHI", Indiv), "Chicago", "Autres"),
    Commodity = case_when(
      grepl("CORN", Indiv, ignore.case = TRUE) ~ "CORN",
      grepl("WHEAT", Indiv, ignore.case = TRUE) ~ "WHEAT",
      TRUE ~ NA_character_
    )
  ) %>%
  filter(!is.na(Commodity))

# üîπ √âtape 2 : moyenne par Date et groupe
pretrend_summary <- a1_pre %>%
  group_by(Date, Treatment, Commodity) %>%
  summarise(mean_price = mean(Close, na.rm = TRUE), .groups = "drop")

# üîπ √âtape 3 : graphique pour le CORN
ggplot(pretrend_summary %>% filter(Commodity == "CORN"),
       aes(x = Date, y = mean_price, color = Treatment)) +
  geom_line(linewidth = 1) +
  labs(title = "Tendances pr√©-traitement - CORN",
       subtitle = "Chicago vs autres march√©s",
       x = "Date", y = "Prix moyen de cl√¥ture") +
  scale_color_manual(values = c("Chicago" = "darkred", "Autres" = "steelblue")) +
  geom_vline(xintercept = as.Date("1926-02-01"), linetype = "dashed", color = "black") +
  theme_minimal() +
  theme(legend.position = "top")

# üîπ √âtape 4 : graphique pour le WHEAT
ggplot(pretrend_summary %>% filter(Commodity == "WHEAT"),
       aes(x = Date, y = mean_price, color = Treatment)) +
  geom_line(linewidth = 1) +
  labs(title = "Tendances pr√©-traitement - WHEAT",
       subtitle = "Chicago vs autres march√©s",
       x = "Date", y = "Prix moyen de cl√¥ture") +
  scale_color_manual(values = c("Chicago" = "darkred", "Autres" = "steelblue")) +
  geom_vline(xintercept = as.Date("1926-02-01"), linetype = "dashed", color = "black") +
  theme_minimal() +
  theme(legend.position = "top")

```

# GRAPHIQUE DE CHAQUE MATI√àRE PREMI√àRE ET VOLATILIT√âS

## MAY

### Filtrage des contrats √©ch√©ance MAY (bl√© et ma√Øs)

```{r filter-mai}
contracts_mai <- a1[grepl("MAY", a1$Indiv), ]
contracts_mai_wheat <- contracts_mai[grepl("WHEAT", contracts_mai$Indiv), ]
contracts_mai_corn <- contracts_mai[grepl("CORN", contracts_mai$Indiv), ]
```

### Visualisation des prix de cl√¥ture - √©ch√©ance MAY - WHEAT

```{r graph-mai-wheat}
ggplot(subset(contracts_mai_wheat, !is.na(Close)), aes(x = Date, y = Close, color = Indiv)) +
  geom_line(linewidth = 1) +
  labs(,
       x = "Date", y = "Prix de cl√¥ture") +
  geom_vline(xintercept = as.Date("1926-02-01"), linetype = "dashed") +
  scale_x_date(date_breaks = "1 week", date_labels = "%b %d") +
  theme_minimal()
```

### Visualisation des prix de cl√¥ture - √©ch√©ance MAY - CORN

```{r graph-mai-corn}
ggplot(subset(contracts_mai_corn, !is.na(Close)), aes(x = Date, y = Close, color = Indiv)) +
  geom_line(linewidth = 1) +
  labs(
       x = "Date", y = "Prix de cl√¥ture") +
  geom_vline(xintercept = as.Date("1926-02-01"), linetype = "dashed") +
  scale_x_date(date_breaks = "1 week", date_labels = "%b %d") +
  theme_minimal()
```





### Calcul de la volatilit√© simple par contrat - MAY

```{r}
library(dplyr)

# Filtrer les donn√©es pour les contrats MAY
contracts_mai <- a1[grepl("MAY", a1$Indiv), ]

# Calculer la volatilit√© avant et apr√®s la r√©forme pour les contrats MAY
vol_mai <- contracts_mai %>%
  mutate(P√©riode = ifelse(Date < as.Date("1926-02-01"), "Avant", "Apr√®s")) %>%
  group_by(Indiv, P√©riode) %>%
  summarise(volatilite = sd(Close, na.rm = TRUE), .groups = "drop")

# Afficher la volatilit√© avant et apr√®s pour les contrats MAY
print(vol_mai)

# Calculer la diff√©rence de volatilit√© avant et apr√®s pour chaque contrat
vol_diff_mai <- vol_mai %>%
  spread(key = P√©riode, value = volatilite) %>%
  mutate(Diff√©rence = `Apr√®s` - `Avant`)

# Afficher la diff√©rence de volatilit√©
print(vol_diff_mai)

```




## JULY

### Filtrage des contrats √©ch√©ance JULY (bl√© et ma√Øs)

```{r filter-july}
contracts_july <- a1[grepl("JULY", a1$Indiv), ]
contracts_july_wheat <- contracts_july[grepl("WHEAT", contracts_july$Indiv), ]
contracts_july_corn <- contracts_july[grepl("CORN", contracts_july$Indiv), ]
```

### Visualisation des prix de cl√¥ture - √©ch√©ance JULY - WHEAT

```{r graph-july-wheat}
ggplot(subset(contracts_july_wheat, !is.na(Close)), aes(x = Date, y = Close, color = Indiv)) +
  geom_line(linewidth = 1) +
  labs(
       x = "Date", y = "Prix de cl√¥ture") +
  geom_vline(xintercept = as.Date("1926-02-01"), linetype = "dashed") +
  scale_x_date(date_breaks = "1 week", date_labels = "%b %d") +
  theme_minimal()
```

### Visualisation des prix de cl√¥ture - √©ch√©ance JULY - CORN

```{r graph-july-corn}
ggplot(subset(contracts_july_corn, !is.na(Close)), aes(x = Date, y = Close, color = Indiv)) +
  geom_line(linewidth = 1) +
  labs(
       x = "Date", y = "Prix de cl√¥ture") +
  geom_vline(xintercept = as.Date("1926-02-01"), linetype = "dashed") +
  scale_x_date(date_breaks = "1 week", date_labels = "%b %d") +
  theme_minimal()
```

### Visualisation graphique de l'effet DiD estim√© - √©ch√©ance JULY

```{r graph-did-july}
a1_did_sample_july <- rbind(
  a1[grepl("CHI-WHEAT-JULY", a1$Indiv), ],
  a1[grepl("KC_WHEAT_JULY|STL-WHEAT-JULY", a1$Indiv), ]
)
a1_did_sample_july <- a1_did_sample_july %>%
  mutate(Groupe = ifelse(grepl("CHI", Indiv), "Treated", "Control"),
         P√©riode = factor(ifelse(as.Date(Date) >= as.Date("1926-02-01"), "Apr√®s", "Avant"), levels = c("Avant", "Apr√®s")))

mean_did_july <- a1_did_sample_july %>%
  group_by(Groupe, P√©riode) %>%
  summarise(Prix_moyen = mean(Close, na.rm = TRUE), .groups = "drop")

ggplot(mean_did_july, aes(x = P√©riode, y = Prix_moyen, group = Groupe, color = Groupe)) +
  geom_line(linewidth = 1.5) +
  geom_point(size = 3) +
  labs(title = "Effet estim√© de la novation (DiD) - Contrats JULY",
       x = "P√©riode", y = "Prix moyen") +
  theme_minimal()
```


### Calcul de la volatilit√© simple par contrat - JULY

```{r}
# Filtrer les contrats √©ch√©ance JULY (bl√© et ma√Øs)
contracts_july <- a1[grepl("JULY", a1$Indiv), ]

# Diviser les contrats de juillet pour le bl√© et le ma√Øs
contracts_july_wheat <- contracts_july[grepl("WHEAT", contracts_july$Indiv), ]
contracts_july_corn <- contracts_july[grepl("CORN", contracts_july$Indiv), ]


# Calcul de la volatilit√© avant et apr√®s la r√©forme pour les contrats JULY
vol_july <- contracts_july %>%
  mutate(P√©riode = ifelse(Date < as.Date("1926-02-01"), "Avant", "Apr√®s")) %>%
  group_by(Indiv, P√©riode) %>%
  summarise(volatilite = sd(Close, na.rm = TRUE), .groups = "drop")

# Afficher la volatilit√© avant et apr√®s pour les contrats JULY
print(vol_july)

# Calculer la diff√©rence de volatilit√© avant et apr√®s pour chaque contrat JULY
vol_diff_july <- vol_july %>%
  spread(key = P√©riode, value = volatilite) %>%
  mutate(Diff√©rence = `Apr√®s` - `Avant`)

# Afficher la diff√©rence de volatilit√©
print(vol_diff_july)


```


## Volatilit√© g√©n√©rale avant et apr√®s la r√©forme pour chaque ville (Chicago, Kansas City, St. Louis) et pour MAY et JULY
```{r}
# Filtrer les contrats √©ch√©ance MAY et JULY (bl√© et ma√Øs) pour chaque ville
contracts_may_july <- a1[grepl("MAY|JULY", a1$Indiv), ]

# Ajouter une colonne pour la p√©riode (avant et apr√®s la novation)
contracts_may_july <- contracts_may_july %>%
  mutate(P√©riode = ifelse(Date < as.Date("1926-02-01"), "Avant", "Apr√®s"),
         Ville = case_when(
           grepl("CHI", Indiv) ~ "Chicago",
           grepl("KC", Indiv) ~ "Kansas City",
           grepl("STL", Indiv) ~ "St. Louis"
         ))

# Calculer la volatilit√© g√©n√©rale avant et apr√®s la r√©forme pour chaque ville (Chicago, Kansas City, St. Louis)
volatilite_generale_may_july_villes <- contracts_may_july %>%
  group_by(Ville, P√©riode) %>%
  summarise(volatilite_totale = sd(Close, na.rm = TRUE), .groups = "drop")

# Afficher la volatilit√© g√©n√©rale avant et apr√®s pour chaque ville (Chicago, Kansas City, St. Louis) et pour MAY et JULY
print(volatilite_generale_may_july_villes)

volatilite_generale_may_july_villes <- contracts_may_july %>%
  group_by(Ville, P√©riode) %>%
  summarise(volatilite_totale = sd(Close, na.rm = TRUE), .groups = "drop")

# Utiliser spread pour organiser les donn√©es par p√©riode
vol_diff_may_july <- volatilite_generale_may_july_villes %>%
  spread(key = P√©riode, value = volatilite_totale) %>%
  mutate(Diff√©rence = `Apr√®s` - `Avant`)

# Afficher la diff√©rence de volatilit√© g√©n√©rale
print(vol_diff_may_july)

```




# DIFFERENCES-EN-DIFFERENCES (DID)

```{r}
# Fonction pour ex√©cuter un mod√®le DiD TWFE avec erreurs standards Driscoll-Kraay
run_did <- function(data, contract_name) {
  data$Date <- as.Date(as.character(data$Date))

  # Cr√©er les variables AVANT de passer en pdata.frame
  treat <- ifelse(grepl("CHI", data$Indiv), 1, 0)
  post <- ifelse(data$Date >= as.Date("1926-02-01"), 1, 0)
  data$Treat_Post <- treat * post

  # Panelisation
  data <- pdata.frame(data, index = c("Indiv", "Date"))

  # R√©gression TWFE
  model <- tryCatch({
    plm(Close ~ Treat_Post, data = data, effect = "twoways", model = "within", na.action = na.omit)
  }, error = function(e) NULL)

  if (is.null(model)) {
    return(tibble(
      Contrat = contract_name,
      Coef = NA,
      SE = NA,
      Stars = NA,
      N = NA,
      T = NA,
      NT = NA
    ))
  }

  est <- coef(model)["Treat_Post"]
  se <- coeftest(model, vcovSCC(model, type = "HC0"))["Treat_Post", "Std. Error"]
  tval <- est / se
  pval <- 2 * pt(abs(tval), df = model$df.residual, lower.tail = FALSE)
  stars <- ifelse(pval < 0.001, "***", ifelse(pval < 0.01, "**", ifelse(pval < 0.05, "*", "")))

  N <- length(unique(data$Indiv))
  T <- length(unique(data$Date))
  NT <- nobs(model)

  return(tibble(
    Contrat = contract_name,
    Coef = round(est, 3),
    SE = paste0(format(round(se, 3), nsmall = 3), stars),
    N = N,
    T = T,
    NT = NT
  ))
}
# Liste des sous-√©chantillons √† tester
contrats <- list(
  "May wheat"  = a1[grepl("WHEAT.MAY",  a1$Indiv), ],
  "July wheat" = a1[grepl("WHEAT.JULY", a1$Indiv), ],
  "May corn"   = a1[grepl("CORN.MAY",   a1$Indiv), ],
  "July corn"  = a1[grepl("CORN.JULY",  a1$Indiv), ]
)

# Application de la fonction sur chaque contrat
results_did <- bind_rows(lapply(names(contrats), function(nom) {
  run_did(contrats[[nom]], nom)
}))

# Affichage du tableau final
print(results_did)


```


# SPREAD

```{r}

# Filtrage des contrats pour Mai et Juillet
contracts_may_july <- a1[grepl("MAY|JULY", a1$Indiv), ]

# Cr√©ation de la variable de p√©riode (avant et apr√®s novation)
contracts_may_july <- contracts_may_july %>%
  mutate(P√©riode = ifelse(Date < as.Date("1926-02-01"), "Avant", "Apr√®s"),
         Ville = case_when(
           grepl("CHI", Indiv) ~ "Chicago",
           grepl("KC", Indiv) ~ "Kansas City",
           grepl("STL", Indiv) ~ "St. Louis"
         ),
         C√©r√©ale = case_when(
           grepl("CORN", Indiv) ~ "Ma√Øs",  # Si le contrat contient "CORN", il s'agit de ma√Øs
           grepl("WHEAT", Indiv) ~ "Bl√©"   # Si le contrat contient "WHEAT", il s'agit de bl√©
         ))

# Extraire les prix de Chicago
chicago_prices <- contracts_may_july %>%
  filter(grepl("CHI", Indiv)) %>%
  dplyr::select(Date, Close) %>%
  rename(Chicago_Price = Close)

# Joindre les prix de Chicago avec les autres villes pour calculer le spread
contracts_may_july <- contracts_may_july %>%
  left_join(chicago_prices, by = "Date")

# Calcul du spread pour chaque ligne en utilisant les prix de Chicago
contracts_may_july <- contracts_may_july %>%
  mutate(Spread = Close - Chicago_Price)

```


## May

### Bl√©

```{r}
# Calcul de la moyenne des spreads avant et apr√®s la r√©forme pour Mai, Bl√©
spread_avg_may_wheat <- contracts_may_july %>%
  filter(grepl("MAY", Indiv), C√©r√©ale == "Bl√©") %>%
  group_by(Ville, P√©riode) %>%
  summarise(Spread_Moyenne = mean(Spread, na.rm = TRUE), .groups = "drop")

# Calcul de la diff√©rence des spreads pour Mai, Bl√©
spread_diff_may_wheat <- spread_avg_may_wheat %>%
  spread(key = P√©riode, value = Spread_Moyenne) %>%
  mutate(Diff√©rence = `Apr√®s` - `Avant`)

# Affichage des r√©sultats
cat("\nR√©sultats pour Mai - Bl√© :\n")
print(spread_diff_may_wheat)

```


### Ma√Øs

```{r}
# Calcul de la moyenne des spreads avant et apr√®s la r√©forme pour Mai, Ma√Øs
spread_avg_may_maize <- contracts_may_july %>%
  filter(grepl("MAY", Indiv), C√©r√©ale == "Ma√Øs") %>%
  group_by(Ville, P√©riode) %>%
  summarise(Spread_Moyenne = mean(Spread, na.rm = TRUE), .groups = "drop")

# Calcul de la diff√©rence des spreads pour Mai, Ma√Øs
spread_diff_may_maize <- spread_avg_may_maize %>%
  spread(key = P√©riode, value = Spread_Moyenne) %>%
  mutate(Diff√©rence = `Apr√®s` - `Avant`)

# Affichage des r√©sultats
cat("R√©sultats pour Mai - Ma√Øs :\n")
print(spread_diff_may_maize)

```



## July

### Bl√©

```{r}
# Calcul de la moyenne des spreads avant et apr√®s la r√©forme pour Juillet, Bl√©
spread_avg_july_wheat <- contracts_may_july %>%
  filter(grepl("JULY", Indiv), C√©r√©ale == "Bl√©") %>%
  group_by(Ville, P√©riode) %>%
  summarise(Spread_Moyenne = mean(Spread, na.rm = TRUE), .groups = "drop")

# Calcul de la diff√©rence des spreads pour Juillet, Bl√©
spread_diff_july_wheat <- spread_avg_july_wheat %>%
  spread(key = P√©riode, value = Spread_Moyenne) %>%
  mutate(Diff√©rence = `Apr√®s` - `Avant`)

# Affichage des r√©sultats
cat("\nR√©sultats pour Juillet - Bl√© :\n")
print(spread_diff_july_wheat)

```

### Ma√Øs

```{r}
# Calcul de la moyenne des spreads avant et apr√®s la r√©forme pour Juillet, Ma√Øs
spread_avg_july_maize <- contracts_may_july %>%
  filter(grepl("JULY", Indiv), C√©r√©ale == "Ma√Øs") %>%
  group_by(Ville, P√©riode) %>%
  summarise(Spread_Moyenne = mean(Spread, na.rm = TRUE), .groups = "drop")

# Calcul de la diff√©rence des spreads pour Juillet, Ma√Øs
spread_diff_july_maize <- spread_avg_july_maize %>%
  spread(key = P√©riode, value = Spread_Moyenne) %>%
  mutate(Diff√©rence = `Apr√®s` - `Avant`)

# Affichage des r√©sultats
cat("\nR√©sultats pour Juillet - Ma√Øs :\n")
print(spread_diff_july_maize)

```


## G√©n√©ral
```{r}
# Calcul des r√©sultats g√©n√©raux pour toutes les villes, pour chaque p√©riode (avant et apr√®s)
spread_avg_general <- contracts_may_july %>%
  group_by(Ville, P√©riode) %>%
  summarise(Spread_Moyenne_Gen = mean(Spread, na.rm = TRUE), .groups = "drop")

# Calcul de la diff√©rence des spreads g√©n√©raux
spread_diff_general <- spread_avg_general %>%
  spread(key = P√©riode, value = Spread_Moyenne_Gen) %>%
  mutate(Diff√©rence = `Apr√®s` - `Avant`)

# Affichage des r√©sultats
cat("\nR√©sultats G√©n√©raux :\n")
print(spread_diff_general)

```




# RECEIPTS AND SHIPMENTS


## Points atypiques

```{r}


# üìÅ Import des donn√©es
df <- read_excel("Dataset1920_ln.xlsx", sheet = "Sheet4")

# üìÖ Transformation des dates et filtrage
df <- df %>%
  mutate(MONTH = as.Date(MONTH)) %>%
  filter(MONTH >= as.Date("1924-01-01") & MONTH <= as.Date("1927-12-31"))

# üéØ Cr√©ation des variables DiD
df <- df %>%
  mutate(
    POST = ifelse(MONTH >= as.Date("1926-02-01"), 1, 0),
    Treat_Post = TREATMENT * POST
  )

# ‚ö†Ô∏è D√©tection des outliers via RosnerTest
rosner_receipts <- rosnerTest(na.omit(df$RECEIPTS), k = 10)
rosner_shipments <- rosnerTest(na.omit(df$SHIPMENTS), k = 10)

rosner_receipts
rosner_shipments
# üîç Extraire les valeurs √† exclure
receipts_outliers <- rosner_receipts$all.stats %>%
  filter(Outlier == TRUE) %>%
  pull(Value)

shipments_outliers <- rosner_shipments$all.stats %>%
  filter(Outlier == TRUE) %>%
  pull(Value)

# üßº Nettoyage de la base (exclusion des outliers)
df_clean <- df %>%
  filter(!RECEIPTS %in% receipts_outliers,
         !SHIPMENTS %in% shipments_outliers)

# üìä Fonction pour afficher des statistiques propres
describe_clean <- function(data, varname) {
  vec <- data[[varname]]
  cat(paste0("\n--- Statistiques descriptives (nettoy√©es) pour ", varname, " ---\n"))
  print(summary(vec))
  cat("√âcart-type :", round(sd(vec, na.rm = TRUE), 2), "\n")
}

# üßæ Statistiques apr√®s nettoyage
describe_clean(df_clean, "RECEIPTS")
describe_clean(df_clean, "SHIPMENTS")

```



## V√©rification tendances parall√®les

### Receipts
```{r}
# üìÖ 1. Filtrer uniquement la p√©riode pr√©-traitement
df_pre <- df %>%
  filter(MONTH < as.Date("1926-02-01")) %>%
  mutate(
    time_to_treat = as.numeric(MONTH - as.Date("1925-01-01")),
    treated_group = ifelse(CITY == "Chicago", 1, 0)
  )

# üîé 2. V√©rification des groupes
table(df_pre$treated_group)  # 1 = Chicago, 0 = autres villes

# üìä 3. R√©gression lin√©aire avec interaction temps * groupe trait√©
model_parallel <- lm(RECEIPTS ~ time_to_treat * treated_group, data = df_pre)
result <- broom::tidy(model_parallel) %>% filter(term == "time_to_treat:treated_group")
print(result)

# üß† 4. Interpr√©tation de l‚Äôinteraction
if (nrow(result) > 0 && !is.na(result$p.value)) {
  pval <- result$p.value
  cat("\n--- Interpr√©tation des tendances parall√®les ---\n")
  if (pval < 0.05) {
    cat("‚ö†Ô∏è Tendance non parall√®le d√©tect√©e (p =", round(pval, 3), ")\n")
  } else {
    cat("‚úÖ Hypoth√®se de tendances parall√®les acceptable (p =", round(pval, 3), ")\n")
  }
} else {
  cat("‚ö†Ô∏è R√©sultat non interpr√©table : interaction non estim√©e.\n")
}

# üìà 5. Visualisation des tendances par groupe (Chicago vs autres)
plot_data <- df_pre %>%
  group_by(MONTH, treated_group) %>%
  summarise(mean_receipts = mean(RECEIPTS, na.rm = TRUE), .groups = "drop")

ggplot(plot_data, aes(x = MONTH, y = mean_receipts, color = factor(treated_group))) +
  geom_line(size = 1) +
  labs(
    x = "Date", y = "Receipts", color = "Groupe trait√©",
   
  ) +
  scale_color_manual(values = c("0" = "grey40", "1" = "steelblue"),
                     labels = c("0" = "Autres villes", "1" = "Chicago")) +
  theme_minimal() +
  theme(legend.position = "bottom")

```

### Shipments

```{r}
# üìÖ 1. Filtrer uniquement la p√©riode pr√©-traitement
df_pre_ship <- df %>%
  filter(MONTH < as.Date("1926-02-01")) %>%
  mutate(
    time_to_treat = as.numeric(MONTH - as.Date("1925-01-01")),
    treated_group = ifelse(CITY == "Chicago", 1, 0)
  )

# üîé 2. V√©rification des groupes
table(df_pre_ship$treated_group)  # 1 = Chicago, 0 = autres villes

# üìä 3. R√©gression lin√©aire avec interaction temps * groupe trait√©
model_parallel_ship <- lm(SHIPMENTS ~ time_to_treat * treated_group, data = df_pre_ship)
result_ship <- broom::tidy(model_parallel_ship) %>% filter(term == "time_to_treat:treated_group")
print(result_ship)


# üß† 4. Interpr√©tation de l‚Äôinteraction
if (nrow(result_ship) > 0 && !is.na(result_ship$p.value)) {
  pval <- result_ship$p.value
  cat("\n--- Interpr√©tation des tendances parall√®les (SHIPMENTS) ---\n")
  if (pval < 0.05) {
    cat("‚ö†Ô∏è Tendance non parall√®le d√©tect√©e (p =", round(pval, 3), ")\n")
  } else {
    cat("‚úÖ Hypoth√®se de tendances parall√®les acceptable (p =", round(pval, 3), ")\n")
  }
} else {
  cat("‚ö†Ô∏è R√©sultat non interpr√©table : interaction non estim√©e.\n")
}

# üìà 5. Visualisation des tendances par groupe (Chicago vs autres)
plot_data_ship <- df_pre_ship %>%
  group_by(MONTH, treated_group) %>%
  summarise(mean_shipments = mean(SHIPMENTS, na.rm = TRUE), .groups = "drop")

ggplot(plot_data_ship, aes(x = MONTH, y = mean_shipments, color = factor(treated_group))) +
  geom_line(size = 1) +
  labs(
    x = "Date", y = "Shipments", color = "Groupe trait√©",
   
  ) +
  scale_color_manual(values = c("0" = "grey40", "1" = "steelblue"),
                     labels = c("0" = "Autres villes", "1" = "Chicago")) +
  theme_minimal() +
  theme(legend.position = "bottom")

```


## TWSE
```{r}
# üß™ Fonction d‚Äôestimation TWFE (DiD) avec erreurs robustes
run_did <- function(outcome_name) {
  data <- df_clean %>% filter(!is.na(.data[[outcome_name]]))
  panel <- pdata.frame(data, index = c("INDIVIDU", "MONTH"))

  model <- plm(as.formula(paste(outcome_name, "~ Treat_Post")),
               data = panel,
               effect = "twoways", model = "within", na.action = na.omit)

  se <- coeftest(model, vcovSCC(model, type = "HC0"))["Treat_Post", "Std. Error"]
  est <- coef(model)["Treat_Post"]
  tval <- est / se
  pval <- 2 * pt(abs(tval), df = model$df.residual, lower.tail = FALSE)
  stars <- ifelse(pval < 0.001, "***", ifelse(pval < 0.01, "**",
                  ifelse(pval < 0.05, "*", "")))

  N <- length(unique(data$INDIVIDU))
  N1 <- length(unique(data$INDIVIDU[data$TREATMENT == 1]))
  N0 <- length(unique(data$INDIVIDU[data$TREATMENT == 0]))
  T <- length(unique(data$MONTH))
  T1 <- length(unique(data$MONTH[data$POST == 1]))
  T0 <- length(unique(data$MONTH[data$POST == 0]))
  NT <- nobs(model)

  return(tibble(
    Outcome = outcome_name,
    Coef = round(est, 3),
    SE = paste0(format(round(se, 3), nsmall = 3), stars),
    N = N, N0 = N0, N1 = N1,
    T = T, T0 = T0, T1 = T1,
    NT = NT
  ))
}

# üßæ Ex√©cution sur RECEIPTS et SHIPMENTS (nettoy√©s)
results_novation_clean <- bind_rows(
  run_did("RECEIPTS"),
  run_did("SHIPMENTS")
)

# üñ•Ô∏è Affichage des r√©sultats
print(results_novation_clean)

```



## Estimation SDiD pour Receipt

```{r}
library(synthdid)
library(dplyr)

# üìÑ Pr√©parer les donn√©es panel pour RECEIPTS (base originale car pas d'outliers)
panel_receipts <- df %>%
  dplyr::select(INDIVIDU, MONTH, RECEIPTS, TREATMENT) %>%
  filter(!is.na(RECEIPTS)) %>%
  arrange(INDIVIDU, MONTH)

# ‚öñÔ∏è Identifier les unit√©s avec donn√©es compl√®tes
nb_periods <- length(unique(panel_receipts$MONTH))

valid_units <- panel_receipts %>%
  group_by(INDIVIDU) %>%
  summarise(n_obs = n()) %>%
  filter(n_obs == nb_periods) %>%
  pull(INDIVIDU)

# üßº Garder panel √©quilibr√©
panel_receipts_balanced <- panel_receipts %>%
  filter(INDIVIDU %in% valid_units)

# üß™ Matrice synthdid
Ymat_receipts <- panel.matrices(as.data.frame(panel_receipts_balanced),
                                unit = 1, time = 2, outcome = 3, treatment = 4)

# üìà Estimation SDiD
tau_sdid_receipts <- synthdid_estimate(Ymat_receipts$Y, Ymat_receipts$N0, Ymat_receipts$T0)

# üìù R√©sum√©
summary(tau_sdid_receipts)
plot(tau_sdid_receipts)

# üéØ IC placebo
se_rec <- sqrt(vcov(tau_sdid_receipts, method = "placebo"))

sprintf("Point estimate: %1.2f", tau_sdid_receipts)
sprintf("95%% CI: (%1.2f, %1.2f)", tau_sdid_receipts - 1.96 * se_rec, tau_sdid_receipts + 1.96 * se_rec)


```






## Estimation SDiD pour Shipment

```{r}


# üìÑ Pr√©parer les donn√©es panel
panel_shipments <- df_clean %>%
  dplyr::select(INDIVIDU, MONTH, SHIPMENTS, TREATMENT) %>%
  filter(!is.na(SHIPMENTS)) %>%
  arrange(INDIVIDU, MONTH)

# ‚öñÔ∏è Cr√©er un panel √©quilibr√© : unit√©s avec donn√©es √† chaque p√©riode
nb_periods_ship <- length(unique(panel_shipments$MONTH))

valid_units_ship <- panel_shipments %>%
  group_by(INDIVIDU) %>%
  summarise(n_obs = n()) %>%
  filter(n_obs == nb_periods_ship) %>%
  pull(INDIVIDU)

# üîÅ Panel √©quilibr√© uniquement
panel_shipments_balanced <- panel_shipments %>%
  filter(INDIVIDU %in% valid_units_ship)

# üß™ Construire la matrice synthdid
Ymat_shipments <- panel.matrices(as.data.frame(panel_shipments_balanced),
                                 unit = 1, time = 2, outcome = 3, treatment = 4)

# üìà Estimation SDiD
tau_sdid_ship <- synthdid_estimate(Ymat_shipments$Y, Ymat_shipments$N0, Ymat_shipments$T0)

# üìù R√©sum√©
summary(tau_sdid_ship)

# üìä Visualisation
plot(tau_sdid_ship)

# üéØ Intervalle de confiance (placebo)
se_ship <- sqrt(vcov(tau_sdid_ship, method = "placebo"))
sprintf("Point estimate: %1.2f", tau_sdid_ship)
sprintf("95%% CI: (%1.2f, %1.2f)", tau_sdid_ship - 1.96 * se_ship, tau_sdid_ship + 1.96 * se_ship)

```







# OPEN INTEREST

```{r}
# üì¶ Chargement des packages n√©cessaires
library(readxl)
library(dplyr)
library(ggplot2)
library(broom)

# üìÅ Charger les donn√©es
oc_data <- read_excel("open_commitment_1920s.xlsx", sheet = "OC3")

# üßº Nettoyage et construction de la date
oc_data <- oc_data %>%
  mutate(
    Date = as.Date(paste(Year, Month, Day, sep = "-")),
    Treatment = ifelse(City == "Chicago", 1, 0)
  ) %>%
  filter(!is.na(Open_Commitment))  # garde seulement les lignes valides
```

## V√©rification des tendances parall√®les 

```{r}
# üìÜ Donn√©es pr√©-traitement uniquement
oc_pre <- oc_data %>%
  filter(Date < as.Date("1926-02-01")) %>%
  mutate(time_to_treat = as.numeric(Date - as.Date("1925-01-01")))

# ‚úÖ V√©rification de la distribution des groupes
print(table(oc_pre$City))
print(table(oc_pre$Treatment))

# üìä R√©gression pour tester les tendances parall√®les
model_parallel <- lm(Open_Commitment ~ time_to_treat + Treatment + time_to_treat*Treatment, data = oc_pre)
result <- tidy(model_parallel) %>% filter(term == "time_to_treat:Treatment")
print(result)

# üîç Interpr√©tation simple
if (nrow(result) > 0) {
  pval <- result$p.value
  cat("\n--- Interpr√©tation ---\n")
  if (pval < 0.05) {
    cat("‚ö†Ô∏è Tendance non parall√®le d√©tect√©e (p =", round(pval, 3), ")\n")
  } else {
    cat("‚úÖ Hypoth√®se de tendances parall√®les acceptable (p =", round(pval, 3), ")\n")
  }
}

# üìà Visualisation des tendances pr√©-traitement par ville
plot_data <- oc_pre %>%
  group_by(Date, City) %>%
  summarise(mean_oc = mean(Open_Commitment, na.rm = TRUE), .groups = "drop")

ggplot(plot_data, aes(x = Date, y = mean_oc, color = City)) +
  geom_line(size = 1) +
  labs(
       x = "Date", y = "Open Commitments") +
  theme_minimal() +
  theme(legend.position = "bottom")

```



## Points atypiques
```{r}
# üì¶ Packages pour d√©tection de valeurs atypiques
library(EnvStats)

# Appliquer le test de Rosner sur Open_Commitment
rosner_result <- rosnerTest(oc_data$Open_Commitment, k = 10, alpha = 0.05)

# R√©sultat du test
print(rosner_result)

```

```{r}
# Extraire les num√©ros d'observations √† exclure
outliers_index <- rosner_result$all.stats %>%
  filter(Outlier == TRUE) %>%
  pull(Obs.Num)

# Exclure ces observations de la base
oc_data_clean <- oc_data[-outliers_index, ]

```



## Statistiques descriptives 
```{r}
# Statistiques descriptives globales sur les engagements ouverts
summary_stats <- oc_data_clean %>%
  summarise(
    N = n(),
    Moyenne = mean(Open_Commitment, na.rm = TRUE),
    M√©diane = median(Open_Commitment, na.rm = TRUE),
    √âcart_type = sd(Open_Commitment, na.rm = TRUE),
    Min = min(Open_Commitment, na.rm = TRUE),
    Max = max(Open_Commitment, na.rm = TRUE)
  )

print(summary_stats)

```


## Mod√®le DID pour calculer les open interest 

```{r}
# üîÅ Ajouter les variables POST et Treat_Post
oc_data_clean <- oc_data_clean %>%
  mutate(
    POST = ifelse(Date >= as.Date("1926-02-01"), 1, 0),
    Treat_Post = Treatment * POST
  )

# üìê Cr√©er le panel propre
oc_panel_clean <- pdata.frame(oc_data_clean, index = c("Indiv", "Date"))

# üìä R√©gression DiD avec effets fixes (Driscoll-Kraay robust)
did_model_clean <- plm(Open_Commitment ~ Treat_Post,
                       data = oc_panel_clean,
                       model = "within", effect = "twoways")

did_result_clean <- coeftest(did_model_clean, vcov = vcovSCC(did_model_clean, type = "HC0"))

# üßæ R√©sum√© format√©
summary_did_clean <- tidy(did_result_clean) %>%
  filter(term == "Treat_Post") %>%
  mutate(
    signif = case_when(
      p.value < 0.001 ~ "***",
      p.value < 0.01  ~ "**",
      p.value < 0.05  ~ "*",
      p.value < 0.1   ~ ".",
      TRUE            ~ ""
    )
  )

print(summary_did_clean)

```

